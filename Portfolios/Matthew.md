# Matthew's Portfolio
## Week 1 (1/31 - 2/7)
 
  During our first meeting on 1/31, we discussed methods and algorithms to find the 2D convex hull given a set of points. Throughout our discussion, we were able to land on the gift wrapping algorithm first. I found this algorithm to be the most intuitive to understand. Initially, my mindset was very focused on visual ways that a human could find a convex hull, such as visually shrinking a large circle like a rubber band to then fit over all points that would form the hull. As Lam mentioned though, what is easy for the human brain to do would be very hard for the computer to execute. Thus, I found the gift wrapping method to meet in the middle of this nice visual of what the algorithm was doing, while also being manageable to code and for the computer to execute. 
  
  As we wrapped up our discussion, we were also introduced to the quick hull method, where we can split our set of points into two and form convex hulls between smaller sets of points that can be rejoined back together to form the whole convex hull. Compared to the gift wrapping algorithm, I found this method unintuitive at first, but rationalizing this method as a divide and conquer sort of idea made it more familiar. Walking away from our meeting, I had an idea of wanting to implement something along the lines of the gift wrapping algorithm, or something that used the angular behavior between lines to actually formulate the convex hull.
  
  As I began to actually start coding, I found I was stumped on where to actually start formulating the algorithm to iterate through the set of points. It was difficult identifying what needed to be tracked during each iteration, and when it was okay to move on to testing the angle of another set of points. Initially, I wanted to use some sort of dot product function to track the angle between any three consecutive points that were being tested as a part of the convex hull (the "middle" point would act as an base of the vector while the other two points would be the head forming two different vectors). While I had coded this function, trying to implement it as a part of my algorithm didn't seem very fitting, as the dot product was not able to convey the greatest amount of information apart from the behavior of the angle, not whether it was directionally correct or not.


## Week 2 (2/7 - 2/14)


During our meeting on the 7th, we discussed further about our algorithms to find the convex hull given a set of points. Rather than focusing on the conceptual formation of our algorithms, we dove more into the nitty gritty coding side of our algorithms. Prior to the meeting, I was searching online for other possible convex hull algorithms I could implement that were also efficient at the same time. This led me down the rabbit hole to finding the graham scan algorithm, which uses the orientation [(link)](https://www.geeksforgeeks.org/orientation-3-ordered-points/) of an ordered set of 3 points to determine if a point is on the hull or not. I found this idea of orientation also much easier to apply in the context of our problem as a test for points on our hull as well, as this characteristic only required two other points to make a relative measuring. 

When implementing the graham scan algorithm, I found the process of iterating through points to be pretty straightforward. First, I had to start with the point with the lowest y-value (the anchor point), and then measure the polar angle made between all other points and the anchor point. I then sort the points by this polar angle from smallest angle to greatest for the algorithm to then iterate through to test orientability. Here, it is important to understand in terms of orientation, we want any 3 consecutive points on our convex hull to have counterclockwise orientation. That way, when iterating through points, the convex hull is able to form lines between hull points in counterclockwise order moving through the points sorted from smallest angle to greatest. The algorithm would then iterate through each point and check if the orientation of the next point formed a counterclockwise turn, thus slowly wrapping around the entire convex hull.

I found my generated plots of this also turned out pretty well using a set of 100 randomly generated points:

![image](https://github.com/AlecTraas/computational-geo-lab/assets/158364295/bc68f009-f845-4b78-890a-7b67f03e1d55)

While this seems to work as a general solution, I am unsure of how edge cases would hold up in the algorithm I've coded. In the future, I hope to dive more in depth into edge cases that dive into collinearity between points.
