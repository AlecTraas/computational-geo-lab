# Matthew's Portfolio
## Week 1 (1/31 - 2/7)
 
  During our first meeting on 1/31, we discussed methods and algorithms to find the 2D convex hull given a set of points. Throughout our discussion, we were able to land on the gift wrapping algorithm first. I found this algorithm to be the most intuitive to understand. Initially, my mindset was very focused on visual ways that a human could find a convex hull, such as visually shrinking a large circle like a rubber band to then fit over all points that would form the hull. As Lam mentioned though, what is easy for the human brain to do would be very hard for the computer to execute. Thus, I found the gift wrapping method to meet in the middle of this nice visual of what the algorithm was doing, while also being manageable to code and for the computer to execute. 
 
  As we wrapped up our discussion, we were also introduced to the quick hull method, where we can split our set of points into two and form convex hulls between smaller sets of points that can be rejoined back together to form the whole convex hull. Compared to the gift wrapping algorithm, I found this method unintuitive at first, but rationalizing this method as a divide and conquer sort of idea made it more familiar. Walking away from our meeting, I had an idea of wanting to implement something along the lines of the gift wrapping algorithm, or something that used the angular behavior between lines to actually formulate the convex hull.
 
  As I began to actually start coding, I found I was stumped on where to actually start formulating the algorithm to iterate through the set of points. It was difficult identifying what needed to be tracked during each iteration, and when it was okay to move on to testing the angle of another set of points. Initially, I wanted to use some sort of dot product function to track the angle between any three consecutive points that were being tested as a part of the convex hull (the "middle" point would act as an base of the vector while the other two points would be the head forming two different vectors). While I had coded this function, trying to implement it as a part of my algorithm didn't seem very fitting, as the dot product was not able to convey the greatest amount of information apart from the behavior of the angle, not whether it was directionally correct or not.
